use std::str::FromStr;
use crate::ast::*;
use crate::lexer::*;

grammar;

pub Program: StatementList = "\n"? <s: StatementList> => s;

Statement: Statement = {
	<f: ForLoop> => Statement::ForLoop(f),
	<w: WhileLoop> => Statement::WhileLoop(w),
	<f: IfStatement> => Statement::IfStatement(f),
	<c: CaseOf> => Statement::CaseOf(c),
	<r: ReturnStatement> => Statement::ReturnStatement(r),
	<f: FuncDefinition> => Statement::FuncDefinition(f),
	<a: Assignment> => Statement::Assignment(a),
	<e: Expr> => Statement::Expr(e),
};

FuncDefinition: FuncDefinition = "func" <id: Identifier> "(" <args: Comma<Identifier>> ")" "\n"? "{" "\n" <body: StatementList> "}" => FuncDefinition {
	name: id,
	args: args,
	body: body,
};

StatementList: StatementList = <v: Newline<Statement>> => StatementList {
	statements: v,
};

Assignment: Assignment = <n: Identifier> "=" <e: Expr> => Assignment {
	name: n,
	val: e,
};

ReturnStatement: ReturnStatement = "return" <e: Expr> => ReturnStatement {
	ret: e,
};

WhileLoop: WhileLoop = "while" <e: Expr> "\n"? "{" "\n"? <body: StatementList> "}" => WhileLoop {
	cond: e,
	body: body,
};

ForLoop: ForLoop = "for" <n: Identifier> "in" <e: Expr> "\n"? "{" "\n"? <body: StatementList> "}" => ForLoop {
	binding: Pattern(n),
	iter: e,
	body: body,
};

CaseOf: CaseOf = "case" <e: Expr> "of" "\n"? "{" "\n"? <c: CommaNewline<Case>> "}" => CaseOf {
	condition: e,
	cases: c,
};

Case: (Expr, StatementList) = {
	<e: Expr> "=>" <s: Statement> => (e, StatementList { statements: vec![s] }),
	<e: Expr> "=>" "\n"? "{" "\n"? <s: StatementList> "}" => (e, s),
};

IfStatement: IfStatement = {
	"if" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" => IfStatement {
		condition: e,
		then_body: b1,
		else_if: None,
		else_body: None,
	},
	"if" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" "else" "\n"? "{" "\n"? <b2: StatementList> "}" => IfStatement {
		condition: e,
		then_body: b1,
		else_if: None,
		else_body: Some(b2),
	},
	"if" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" <etail: ElifTail> => IfStatement {
		condition: e,
		then_body: b1,
		else_if: Some(Box::new(etail)),
		else_body: None,
	},
};

ElifTail: IfStatement = {
	"elif" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" => IfStatement {
		condition: e,
		then_body: b1,
		else_if: None,
		else_body: None,
	},
	"elif" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" "else" "\n"? "{" "\n"? <b2: StatementList> "}" => IfStatement {
		condition: e,
		then_body: b1,
		else_if: None,
		else_body: Some(b2),
	},
	"elif" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" <etail: ElifTail> => IfStatement {
		condition: e,
		then_body: b1,
		else_if: Some(Box::new(etail)),
		else_body: None,
	},
};

Expr: Expr = <e: LogicalExpr> => e;

LogicalExpr: Expr = {
	<b: Comparison> => b,
	"!" <s1: Comparison> => Expr::FuncCall(FuncCall {
		fname: "<not>".to_string(),
		arguments: vec![s1],
	}),
	<s1: Comparison> "||" <s2: Comparison> => Expr::FuncCall(FuncCall {
		fname: "<or>".to_string(),
		arguments: vec![s1, s2],
	}),
	<s1: Comparison> "&&" <s2: Comparison> => Expr::FuncCall(FuncCall {
		fname: "<and>".to_string(),
		arguments: vec![s1, s2],
	}),
};

Comparison: Expr = {
	<b: Sum> => b,
	<s1: Sum> "<=" <s2: Sum> => Expr::FuncCall(FuncCall {
		fname: "<leq>".to_string(),
		arguments: vec![s1, s2],
	}),
	<s1: Sum> ">=" <s2: Sum> => Expr::FuncCall(FuncCall {
		fname: "<geq>".to_string(),
		arguments: vec![s1, s2],
	}),
	<s1: Sum> "<" <s2: Sum> => Expr::FuncCall(FuncCall {
		fname: "<lt>".to_string(),
		arguments: vec![s1, s2],
	}),
	<s1: Sum> ">" <s2: Sum> => Expr::FuncCall(FuncCall {
		fname: "<gt>".to_string(),
		arguments: vec![s1, s2],
	}),
	<s1: Sum> "==" <s2: Sum> => Expr::FuncCall(FuncCall {
		fname: "<eq>".to_string(),
		arguments: vec![s1, s2],
	}),
	<s1: Sum> "!=" <s2: Sum> => Expr::FuncCall(FuncCall {
		fname: "<neq>".to_string(),
		arguments: vec![s1, s2],
	}),
};

Sum: Expr = {
	<b: Term> => b,
	<t1: Term> "+" <t2: Term> => Expr::FuncCall(FuncCall {
		fname: "<add>".to_string(),
		arguments: vec![t1, t2],
	}),
	<t1: Term> "-" <t2: Term> => Expr::FuncCall(FuncCall {
		fname: "<sub>".to_string(),
		arguments: vec![t1, t2],
	}),
};

Term: Expr = {
	<b: BaseExpr> => b,
	<f1: BaseExpr> "*" <f2: BaseExpr> => Expr::FuncCall(FuncCall {
		fname: "<mul>".to_string(),
		arguments: vec![f1, f2],
	}),
	<f1: BaseExpr> "/" <f2: BaseExpr> => Expr::FuncCall(FuncCall {
		fname: "<div>".to_string(),
		arguments: vec![f1, f2],
	}),
};

BaseExpr: Expr = {
	"(" <e:Expr> ")" => e,
	<s: Identifier> => Expr::Variable(s),
	<l: Literal> => Expr::Literal(l),
	<l: ListLiteral> => Expr::ListLiteral(l),
	<t: TupleLiteral> => Expr::TupleLiteral(t),
	<m: MethodCall> => Expr::MethodCall(m),
	<f: FuncCall> => Expr::FuncCall(f),
	<a: AttrLookup> => Expr::AttrLookup(a),
	<i: IndexedExpr> => Expr::IndexedExpr(i),
};

IndexedExpr: IndexedExpr = <b: BaseExpr> "[" <i: Expr> "]" => IndexedExpr {
	parent: Box::new(b),
	index: Box::new(i),
};

Literal: Literal = {
	<n:int_lit> => Literal::Integer(n),
	<f:float_lit> => Literal::Float(f),
	<s:string_lit> => Literal::Str(s),
};

ListLiteral: ListLiteral = "[" <v: Comma<Expr>> "]" => ListLiteral { values: v };

TupleLiteral: TupleLiteral = "(" <v: CommaNonEmpty<Expr>> ")" => TupleLiteral { values: v };

Identifier: String = <s:ident> => s.to_owned();


MethodCall: MethodCall = <e: BaseExpr> "." <i: Identifier> "(" <args: Comma<Expr>> ")" => MethodCall {
	parent: Box::new(e),
	call: FuncCall {
		fname: i,
		arguments: args,
	},
};

FuncCall: FuncCall = <i: Identifier> "(" <args: Comma<Expr>> ")" => FuncCall {
	fname: i,
	arguments: args,
};

AttrLookup: AttrLookup = <e: BaseExpr> "." <i: Identifier> => AttrLookup {
	parent: Box::new(e),
	attribute: i,
};

Comma<T>: Vec<T> = {
	<v:(<T> ",")*> <e:T?> => match e {
		None => v,
		Some(e) => {
			let mut v = v;
			v.push(e);
			v
		}
	}
};

Newline<T>: Vec<T> = {
	<v:(<T> "\n")*> => v,
};

CommaNewline<T>: Vec<T> = {
	<v:(<T> "," "\n")*> <e:T?> => match e {
		None => v,
		Some(e) => {
			let mut v = v;
			v.push(e);
			v
		}
	}
};

CommaNonEmpty<T>: Vec<T> = {
	<v:(<T> ",")+> <e:T?> => match e {
		None => v,
		Some(e) => {
			let mut v = v;
			v.push(e);
			v
		}
	}
};

extern {
	type Location = usize;
	type Error = ();

	enum Tok {
		"\n" => Tok::Newline,
		"[" => Tok::OpenBracket,
		"]" => Tok::CloseBracket,
		"{" => Tok::OpenBrace,
		"}" => Tok::CloseBrace,
		"(" => Tok::OpenParen,
		")" => Tok::CloseParen,
		"," => Tok::Comma,
		"." => Tok::Dot,
		"=" => Tok::SingleEq,
		"=>" => Tok::Rarrow,
		"*" => Tok::Mult,
		"/" => Tok::Divide,
		"+" => Tok::Plus,
		"-" => Tok::Minus,
		">" => Tok::Greater,
		"<" => Tok::Lesser,
		"!=" => Tok::Neq,
		"<=" => Tok::Leq,
		">=" => Tok::Geq,
		"==" => Tok::DoubleEq,
		"!" => Tok::Not,
		"||" => Tok::Or,
		"&&" => Tok::And,
		ident => Tok::Identifier(<String>),
		int_lit => Tok::Int(<i64>),
		float_lit => Tok::Float(<f64>),
		string_lit => Tok::StringLit(<String>),
		"if" => Tok::If,
		"then" => Tok::Then,
		"else" => Tok::Else,
		"elif" => Tok::Elif,
		"for" => Tok::For,
		"in" => Tok::In,
		"while" => Tok::While,
		"case" => Tok::Case,
		"of" => Tok::Of,
		"func" => Tok::Func,
		"return" => Tok::Return,
	}
}
