use std::str::FromStr;
use crate::ast::*;
use crate::lexer::*;
use codespan::Span;

grammar;

pub Program: ASTNode<StatementList> = "\n"? <s: StatementList> => s;

Statement: ASTNode<Statement> = {
	<l:@L> <f: ForLoop> <r:@R> => ASTNode::new(Statement::ForLoop(f), l, r),
	<l:@L> <w: WhileLoop> <r:@R> => ASTNode::new(Statement::WhileLoop(w), l, r),
	<l:@L> <f: IfStatement> <r:@R> => ASTNode::new(Statement::IfStatement(f), l, r),
	<l:@L> <c: CaseOf> <r:@R> => ASTNode::new(Statement::CaseOf(c), l, r),
	<l:@L> <re: ReturnStatement> <r:@R> => ASTNode::new(Statement::ReturnStatement(re), l, r),
	<l:@L> <f: FuncDefinition> <r:@R> => ASTNode::new(Statement::FuncDefinition(f), l, r),
	<l:@L> <a: Assignment> <r:@R> => ASTNode::new(Statement::Assignment(a), l, r),
	<l:@L> <e: Expr> <r:@R> => ASTNode::new(Statement::Expr(e.inner), l, r),
};

FuncDefinition: FuncDefinition = "func" <id: Identifier> "(" <args: Comma<Identifier>> ")" "\n"? "{" "\n" <body: StatementList> "}" => FuncDefinition {
	name: id,
	args: args,
	body: body,
};

StatementList: ASTNode<StatementList> = <l:@L> <v: Newline<Statement>> <r:@R> => ASTNode::new(StatementList {
	statements: v,
}, l, r);

Assignment: Assignment = {
	<n: Identifier> "=" <e: Expr> => Assignment {
		name: n, val: e,
	},
	<l:@L> <n: Identifier> <r:@R> <op:@L> "+=" <el:@L> <e: Expr> <er:@R> => Assignment {
		name: n.clone(),
		val: ASTNode::new(Expr::FuncCall(FuncCall {
			fname: ASTNode::new("<add>".to_string(), op, op + 2),
			arguments: vec![ASTNode::new(Expr::Variable(ASTNode::new(n.inner, l, r)), l, er), e],
		}), el, er),
	},
	<l:@L> <n: Identifier> <r:@R> <op:@L> "-=" <el:@L> <e: Expr> <er:@R> => Assignment {
		name: n.clone(),
		val: ASTNode::new(Expr::FuncCall(FuncCall {
			fname: ASTNode::new("<sub>".to_string(), op, op + 2),
			arguments: vec![ASTNode::new(Expr::Variable(ASTNode::new(n.inner, l, r)), l, er), e],
		}), el, er),
	},
	<l:@L> <n: Identifier> <r:@R> <op:@L> "*=" <el:@L> <e: Expr> <er:@R> => Assignment {
		name: n.clone(),
		val: ASTNode::new(Expr::FuncCall(FuncCall {
			fname: ASTNode::new("<mul>".to_string(), op, op + 2),
			arguments: vec![ASTNode::new(Expr::Variable(ASTNode::new(n.inner, l, r)), l, er), e],
		}), el, er),
	},
	<l:@L> <n: Identifier> <r:@R> <op:@L> "/=" <el:@L> <e: Expr> <er:@R> => Assignment {
		name: n.clone(),
		val: ASTNode::new(Expr::FuncCall(FuncCall {
			fname: ASTNode::new("<div>".to_string(), op, op + 2),
			arguments: vec![ASTNode::new(Expr::Variable(ASTNode::new(n.inner, l, r)), l, er), e],
		}), el, er),
	},
};

ReturnStatement: ReturnStatement = "return" <e: Expr> => ReturnStatement {
	ret: e,
};

WhileLoop: WhileLoop = "while" <e: Expr> "\n"? "{" "\n"? <body: StatementList> "}" => WhileLoop {
	cond: e,
	body: body,
};

ForLoop: ForLoop = "for" <n: Identifier> "in" <e: Expr> "\n"? "{" "\n"? <body: StatementList> "}" => ForLoop {
	binding: n,
	iter: e,
	body: body,
};

CaseOf: CaseOf = "case" <e: Expr> "of" "\n"? "{" "\n"? <c: CommaNewline<Case>> "}" => CaseOf {
	condition: e,
	cases: c,
};

Case: (ASTNode<Expr>, ASTNode<StatementList>) = {
	<e: Expr> "=>" <l:@L> <s: Statement> <r:@R> => (e, ASTNode::new(StatementList { statements: vec![s] }, l, r)),
	<e: Expr> "=>" "\n"? "{" "\n"? <s: StatementList> "}" => (e, s),
};

IfStatement: IfStatement = {
	"if" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" => IfStatement {
		condition: e,
		then_body: b1,
		else_if: None,
		else_body: None,
	},
	"if" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" "else" "\n"? "{" "\n"? <b2: StatementList> "}" => IfStatement {
		condition: e,
		then_body: b1,
		else_if: None,
		else_body: Some(b2),
	},
	"if" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" <etail: ElifTail> => IfStatement {
		condition: e,
		then_body: b1,
		else_if: Some(Box::new(etail)),
		else_body: None,
	},
};

ElifTail: IfStatement = {
	"elif" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" => IfStatement {
		condition: e,
		then_body: b1,
		else_if: None,
		else_body: None,
	},
	"elif" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" "else" "\n"? "{" "\n"? <b2: StatementList> "}" => IfStatement {
		condition: e,
		then_body: b1,
		else_if: None,
		else_body: Some(b2),
	},
	"elif" <e: Expr> "\n"? "{" "\n"? <b1: StatementList> "}" <etail: ElifTail> => IfStatement {
		condition: e,
		then_body: b1,
		else_if: Some(Box::new(etail)),
		else_body: None,
	},
};

Expr: ASTNode<Expr> = <l:@L> <e: LogicalExpr> <r:@R> => ASTNode::new(e, l, r);

LogicalExpr: Expr = {
	<b: Comparison> => b,
	<op:@L> "!" <l:@L> <s1: Comparison> <r:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<not>".to_string(), op, op + 1),
		arguments: vec![ASTNode::new(s1, l, r)],
	}),
	<l1:@L> <s1: Comparison> <r1:@R> <op:@L> "||" <l2:@L> <s2: Comparison> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<or>".to_string(), op, op + 2),
		arguments: vec![ASTNode::new(s1, l1, r1), ASTNode::new(s2, l2, r2)],
	}),
	<l1:@L> <s1: Comparison> <r1:@R> <op:@L> "&&" <l2:@L> <s2: Comparison> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<and>".to_string(), op, op + 2),
		arguments: vec![ASTNode::new(s1, l1, r1), ASTNode::new(s2, l2, r2)],
	}),
};

Comparison: Expr = {
	<b: Sum> => b,
	<l1:@L> <s1: Sum> <r1:@R> <op:@L> "<=" <l2:@L> <s2: Sum> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<leq>".to_string(), op, op + 2),
		arguments: vec![ASTNode::new(s1, l1, r1), ASTNode::new(s2, l2, r2)],
	}),
	<l1:@L> <s1: Sum> <r1:@R> <op:@L> ">=" <l2:@L> <s2: Sum> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<geq>".to_string(), op, op + 2),
		arguments: vec![ASTNode::new(s1, l1, r1), ASTNode::new(s2, l2, r2)],
	}),
	<l1:@L> <s1: Sum> <r1:@R> <op:@L> "<" <l2:@L> <s2: Sum> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<lt>".to_string(), op, op + 1),
		arguments: vec![ASTNode::new(s1, l1, r1), ASTNode::new(s2, l2, r2)],
	}),
	<l1:@L> <s1: Sum> <r1:@R> <op:@L> ">" <l2:@L> <s2: Sum> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<gt>".to_string(), op, op + 1),
		arguments: vec![ASTNode::new(s1, l1, r1), ASTNode::new(s2, l2, r2)],
	}),
	<l1:@L> <s1: Sum> <r1:@R> <op:@L> "==" <l2:@L> <s2: Sum> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<eq>".to_string(), op, op + 2),
		arguments: vec![ASTNode::new(s1, l1, r1), ASTNode::new(s2, l2, r2)],
	}),
	<l1:@L> <s1: Sum> <r1:@R> <op:@L> "!=" <l2:@L> <s2: Sum> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<neq>".to_string(), op, op + 2),
		arguments: vec![ASTNode::new(s1, l1, r1), ASTNode::new(s2, l2, r2)],
	}),
};

Sum: Expr = {
	<b: Term> => b,
	<l1:@L> <t1: Term> <r1:@R> <op:@L> "+" <l2:@L> <t2: Term> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<add>".to_string(), op, op + 1),
		arguments: vec![ASTNode::new(t1, l1, r1), ASTNode::new(t2, l2, r2)],
	}),
	<l1:@L> <t1: Term> <r1:@R> <op:@L> "-" <l2:@L> <t2: Term> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<sub>".to_string(), op, op + 1),
		arguments: vec![ASTNode::new(t1, l1, r1), ASTNode::new(t2, l2, r2)],
	}),
	<op:@L> "-" <l:@L> <t: Term> <r:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<neg>".to_string(), op, op + 1),
		arguments: vec![ASTNode::new(t, l, r)],
	}),
};

Term: Expr = {
	<b: BaseExpr> => b,
	<l1:@L> <f1: BaseExpr> <r1:@R> <op:@L> "*" <l2:@L> <f2: BaseExpr> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<mul>".to_string(), op, op + 1),
		arguments: vec![ASTNode::new(f1, l1, r1), ASTNode::new(f2, l2, r2)],
	}),
	<l1:@L> <f1: BaseExpr> <r1:@R> <op:@L> "/" <l2:@L> <f2: BaseExpr> <r2:@R> => Expr::FuncCall(FuncCall {
		fname: ASTNode::new("<div>".to_string(), op, op + 1),
		arguments: vec![ASTNode::new(f1, l1, r1), ASTNode::new(f2, l2, r2)],
	}),
};

BaseExpr: Expr = {
	"(" <e:Expr> ")" => e.inner,
	<s: Identifier> => Expr::Variable(s),
	<l: Literal> => Expr::Literal(l),
	<l: ListLiteral> => Expr::ListLiteral(l),
	<t: TupleLiteral> => Expr::TupleLiteral(t),
	<m: MethodCall> => Expr::MethodCall(m),
	<f: FuncCall> => Expr::FuncCall(f),
	<a: AttrLookup> => Expr::AttrLookup(a),
	<i: IndexedExpr> => Expr::IndexedExpr(i),
};

IndexedExpr: IndexedExpr = <l:@L> <b: BaseExpr> <r:@R> "[" <i: Expr> "]" => IndexedExpr {
	parent: Box::new(ASTNode::new(b, l, r)),
	index: Box::new(i),
};

Literal: Literal = {
	<n:int_lit> => Literal::Integer(n),
	<f:float_lit> => Literal::Float(f),
	<s:string_lit> => Literal::Str(s),
};

ListLiteral: ListLiteral = "[" <v: Comma<Expr>> "]" => ListLiteral { values: v };

TupleLiteral: TupleLiteral = "(" <v: CommaNonEmpty<Expr>> ")" => TupleLiteral { values: v };

Identifier: ASTNode<String> = <l:@L> <s:ident> <r:@R> => ASTNode::new(s.to_owned(), l, r);


MethodCall: MethodCall = <l:@L> <e: BaseExpr> <r:@R> "." <i: Identifier> "(" <args: Comma<Expr>> ")" => MethodCall {
	parent: Box::new(ASTNode::new(e, l, r)),
	call: FuncCall {
		fname: i,
		arguments: args,
	},
};

FuncCall: FuncCall = <i: Identifier> "(" <args: Comma<Expr>> ")" => FuncCall {
	fname: i,
	arguments: args,
};

AttrLookup: AttrLookup = <l1:@L> <e: BaseExpr> <r1:@R> "." <i: Identifier> => AttrLookup {
	parent: Box::new(ASTNode::new(e, l1, r1)),
	attribute: i,
};

Comma<T>: Vec<T> = {
	<v:(<T> ",")*> <e:T?> => match e {
		None => v,
		Some(e) => {
			let mut v = v;
			v.push(e);
			v
		}
	}
};

Newline<T>: Vec<T> = {
	<v:(<T> "\n")*> => v,
};

CommaNewline<T>: Vec<T> = {
	<v:(<T> "," "\n")*> <e:T?> => match e {
		None => v,
		Some(e) => {
			let mut v = v;
			v.push(e);
			v
		}
	}
};

CommaNonEmpty<T>: Vec<T> = {
	<v:(<T> ",")+> <e:T?> => match e {
		None => v,
		Some(e) => {
			let mut v = v;
			v.push(e);
			v
		}
	}
};

extern {
	type Location = usize;
	type Error = ();

	enum Tok {
		"\n" => Tok::Newline,
		"[" => Tok::OpenBracket,
		"]" => Tok::CloseBracket,
		"{" => Tok::OpenBrace,
		"}" => Tok::CloseBrace,
		"(" => Tok::OpenParen,
		")" => Tok::CloseParen,
		"," => Tok::Comma,
		"." => Tok::Dot,
		"=" => Tok::SingleEq,
		"=>" => Tok::Rarrow,
		"*" => Tok::Mult,
		"/" => Tok::Divide,
		"+" => Tok::Plus,
		"-" => Tok::Minus,
		">" => Tok::Greater,
		"<" => Tok::Lesser,
		"!=" => Tok::Neq,
		"<=" => Tok::Leq,
		">=" => Tok::Geq,
		"==" => Tok::DoubleEq,
		"!" => Tok::Not,
		"||" => Tok::Or,
		"&&" => Tok::And,
		"+=" => Tok::AddAssign,
		"-=" => Tok::SubAssign,
		"*=" => Tok::MulAssign,
		"/=" => Tok::DivAssign,
		ident => Tok::Identifier(<String>),
		int_lit => Tok::Int(<i64>),
		float_lit => Tok::Float(<f64>),
		string_lit => Tok::StringLit(<String>),
		"if" => Tok::If,
		"then" => Tok::Then,
		"else" => Tok::Else,
		"elif" => Tok::Elif,
		"for" => Tok::For,
		"in" => Tok::In,
		"while" => Tok::While,
		"case" => Tok::Case,
		"of" => Tok::Of,
		"func" => Tok::Func,
		"return" => Tok::Return,
	}
}
